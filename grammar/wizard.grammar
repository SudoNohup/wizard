(rule $returnFn (is the answer) (ConstantFn (lambda x (call cs.utexas.wizard.translator.WizardFn.returnStmt (var x)))))
(rule $Stmt ($TOKEN $returnFn) (JoinFn backward))

(rule $condExprEqFn (is) (ConstantFn (lambda lhs (lambda rhs (call cs.utexas.wizard.translator.WizardFn.condExprEq (var lhs) (var rhs))))))
(rule $partialStmt ($TOKEN $condExprEqFn) (JoinFn backward))
(rule $Stmt ($partialStmt $TOKEN) (JoinFn forward))

(rule $condExprNeFn (is not) (ConstantFn (lambda lhs (lambda rhs (call cs.utexas.wizard.translator.WizardFn.condExprNe (var lhs) (var rhs))))))
(rule $partialNeStmt ($TOKEN $condExprNeFn) (JoinFn backward))
(rule $Stmt ($partialNeStmt $TOKEN) (JoinFn forward))

(rule $ifFn (if) (ConstantFn (lambda x (call cs.utexas.wizard.translator.WizardFn.ifStmt (var x)))))
(rule $Stmt ($ifFn $Stmt) (JoinFn forward))

(rule $gotoFn ($TOKEN to step) (ConstantFn (lambda x (call cs.utexas.wizard.translator.WizardFn.gotoStmt (var x)))))
(rule $Stmt ($gotoFn $TOKEN) (JoinFn forward))

(rule $assignFn (=) (ConstantFn (lambda lhs (lambda rhs (call cs.utexas.wizard.translator.WizardFn.assignStmt (var lhs) (var rhs))))))
(rule $partialAssignStmt ($TOKEN $assignFn) (JoinFn backward))
(rule $Stmt ($partialAssignStmt $TOKEN) (JoinFn forward))

(rule $ROOT ($Stmt) (IdentityFn))
