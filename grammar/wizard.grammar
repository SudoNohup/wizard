(rule $Expr ($PHRASE) (NumberFn))
(rule $Operator (plus) (ConstantFn (lambda y (lambda x (call + (var x) (var y))))))
(rule $Operator (times) (ConstantFn (lambda y (lambda x (call * (var x) (var y))))))
(rule $Partial ($Operator $Expr) (JoinFn forward))
(rule $Expr ($Expr $Partial) (JoinFn backward))
(rule $ROOT ((what optional) (is optional) $Expr (? optional)) (IdentityFn))
(rule $Function (is the answer) (ConstantFn (lambda ret (var ret))))
(rule $MyRet ($PHRASE $Function) (JoinFn backward))
(rule $ROOT ($MyRet) (IdentityFn))


(rule $EqFn (is) (ConstantFn (lambda y (lambda x (call .indexOf (var x) (var y))))))
(rule $Partial ($EqFn $Expr) (JoinFn forward))
(rule $EqStmt ($PHRASE $Partial) (JoinFn backward))
(rule $ROOT ((if optional) $EqStmt) (IdentityFn))
